[Metadata]
title: 3-Smooth Number
date: 2015-02-18 17:06:46 

[Tags]
difficulty: 3
categories: math
source: mitbbs

[Description]

> In number theory, a smooth (or friable) number is an integer which factors completely into small prime numbers. [Wikipedia]

In this problem, we will try to deal with the **3-smooth number**. The 3-smooth number is a number which only has the factor 2 and 3.

`[1, 2, 3, 4, 6]` are the first few 3-smooth numbers.

You mission is to find a way to generate an array of 3-smooth number in increasing order. The time complexity should be no more than `O(n)` and the memory complexity should be no more than `O(1)`.

[Solution]

Assuming we have already got an array of the first few 3-smooth numbers.

```
1, 2, 3, 4, 6 ...
```

What is the next number of this sequence? The next number, 'x', will be greater than 6. If 'x' is generated by `a * 2`, the number `a` will be greater than 3. If 'x' is generated by `b * 3`, the number `b` should be greater than 2.

```
     pointer-of-2
         v
1, 2, 3, 4, 6 ...
      ^
  pointer-of-3
```

It's easy to find out that `x = 2 * 4 = 8`. And on the next step, the pointer of 2 will move forward to the next number. At the same time, the pointer of 3 will stay the same.

And here is the algorithm and our code:

```python
def smooth_number_3(n):
    res = [0 for i in xrange(n)]
    res[0] = 1
    p2, p3 = 0, 0
    
    for i in xrange(1, n):
        if res[p2] * 2 == res[i - 1]:
            p2 += 1
        if res[p3] * 3 == res[i - 1]:
            p3 += 1
        u2 = res[p2] * 2
        u3 = res[p3] * 3
        if u2 < u3:
            p2 += 1
            res[i] = u2
        else:
            p3 += 1
            res[i] = u3
    return res
    
print smooth_number_3(20)

```
